<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.53">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>XGBoost Aplicado à Séries Temporais</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="jupyter_notebook_files/libs/clipboard/clipboard.min.js"></script>
<script src="jupyter_notebook_files/libs/quarto-html/quarto.js"></script>
<script src="jupyter_notebook_files/libs/quarto-html/popper.min.js"></script>
<script src="jupyter_notebook_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="jupyter_notebook_files/libs/quarto-html/anchor.min.js"></script>
<link href="jupyter_notebook_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="jupyter_notebook_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="jupyter_notebook_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="jupyter_notebook_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="jupyter_notebook_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">XGBoost Aplicado à Séries Temporais</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>
Autor: <a href="https://www.linkedin.com/in/vinicius-aquino-in/" target="_blank" rel="noopener noreferrer">Vinicius Aquino</a>
</p>
<p>
Data: 26/08/2024
</p>
<section id="resumo" class="level2">
<h2 class="anchored" data-anchor-id="resumo">Resumo</h2>
<p>O presente texto é uma introdução aos modelos Gradient Boosting para séries temporais. Nele foram apresentados a classe de modelos de regressão não-paramétrica Gradient Boosting Decision Tree (GBDT) e o XGBoost, uma subclasse dos modelos GBDT. Por fim, foi aplicado o XGBoost no contexto de séries temporais. Apesar de ter sido escolhido o XGBoost, os problemas apresentados no texto, bem com as formas de resolução, podem ser usadas em qualquer Modelo de ML.</p>
<p>Pacotes usados:</p>
<div id="cell-4" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> calendar</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> TimeSeriesSplit</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.tree <span class="im">import</span> DecisionTreeRegressor</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> xgboost <span class="im">import</span> XGBRegressor</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'ggplot'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="gradient-boosting-decision-tree" class="level2">
<h2 class="anchored" data-anchor-id="gradient-boosting-decision-tree">Gradient Boosting Decision Tree:</h2>
<p>Gradient Boosting Decision Tree (GBDT) é uma classe modelo dentro do ramo de regressões não-paramétricas. De forma muito resumnida, Regressões Não-Paramétricas são regressões mais flexíveis, onde o intuito é definir um modelo <span class="math inline">\(r(X)\)</span> que consiga predizer uma variável aleatória <span class="math inline">\(Y\)</span> a partir destas covariáveis. São flexíveis porque não fazem suposições acerca dos parâmetros a serem estimados, muito pelo contrário. Modelos de ML tipicamente são modelos não-paramétricos, como KNN, Redes Neurais e etc.</p>
<p>Voltando a classe de modelos GBDT, como o nome sugere, eles são baseados em árvores de decisão. Diferente do Random Forest, os algoritmos GBDT não usam as árvores de decisão em paralelo. Explica-se. No Random Forest há várias árvores distintas vindas de reamostragens aleatórias de um conjunto de dados, onde a previsão é a média de todas as árvores juntas. No caso dos algoritmos GBDT é usado o processo de “Boosting”, onde se treina sequencialmente novas árvores de decisão que corrigem os erros das anteriores.</p>
<p>Isso é, a primeira árvore é treinada com os dados. A segunda com os resíduos que essa primeira árvore deixou. A terceira com os resíduos da segunda e assim sucessivamente. É um processo iterativo.</p>
<p>Um exemplo abaixo inspirado no livro Mãos à Obra: Aprendizado de Máquina com Scikit-Learn &amp; TensorFlow:</p>
<p>Gerando dados aleatórios:</p>
<div id="cell-7" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">633</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.random.uniform(<span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">100</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> X <span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">5</span> <span class="op">+</span> np.random.normal(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">100</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>ax.scatter(x<span class="op">=</span>X, </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>           y<span class="op">=</span>y, </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>           color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Gradient Boosting Decision Tree"</span>)           </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-3-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Treinando um GBDT (árvores em sequência):</p>
<div id="cell-9" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> X.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>tree_1 <span class="op">=</span> DecisionTreeRegressor(max_depth<span class="op">=</span><span class="dv">3</span>).fit(X, y)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>resid_1 <span class="op">=</span> y <span class="op">-</span> tree_1.predict(X<span class="op">=</span>X) <span class="co"># Residuo da primeira Arvore</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>tree_2 <span class="op">=</span> DecisionTreeRegressor(max_depth<span class="op">=</span><span class="dv">3</span>).fit(X, resid_1)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>resid_2 <span class="op">=</span> resid_1 <span class="op">-</span> tree_2.predict(X<span class="op">=</span>X) <span class="co"># Residuo da segunda Arvore</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>tree_3 <span class="op">=</span> DecisionTreeRegressor(max_depth<span class="op">=</span><span class="dv">3</span>).fit(X, resid_2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Dessa forma, cada árvore se especializou em aprender a “consertar” os erros das arvores que vieram antes. Voltando a ideia de regressão não-paramétrica, o modelo inicial dado é:</p>
<p><span class="math display">\[y_i = r_1(x_1) + \epsilon_{1i} = tree_1(x_i) + \epsilon_{1i}\]</span></p>
<p>A árvore 2 é treinada com os resíduos <span class="math inline">\(\epsilon_{1}\)</span> da árvore 1:</p>
<p><span class="math display">\[(y_i - tree_1(x_i)) = \epsilon_{1i} = r_2(x_1) + \epsilon_{2i} = tree_2(x_i) + \epsilon_{2i}\]</span></p>
<p>Por fim, a árvore 3 é treinada com os resíduos <span class="math inline">\(\epsilon_{2}\)</span> da árvore 2, isso é:</p>
<p><span class="math display">\[(y_i - tree_1(x_i)) - tree_2(x_i)= \epsilon_{2i} = r_3(x_1) + \epsilon_{3i} = tree_3(x_i) + \epsilon_{3i}\]</span></p>
<p>A idéia intuitiva é que se adicione novas árvores conforme isso reduza os erros em teste, até que não seja possível entender os padrões de <span class="math inline">\(\epsilon_{q}\)</span>. Uma ideia similar a de Ruído Branco na metodologia de Box-Jenkis, mas sem supor que tenha distribuição identica, independente e normal.</p>
<p>Pode-se reescrever a equação acima como:</p>
<p><span class="math display">\[y_i - tree_1(x_i) - tree_2(x_i) - tree_3(x_i) = \epsilon_{3i} \]</span></p>
<p><span class="math display">\[ y_i = tree_1(x_i) + tree_2(x_i) + tree_3(x_i) + \epsilon_{3i}\]</span></p>
<p>Ou seja, a previsão da i-esima observação <span class="math inline">\(y\)</span> é a soma das previsões das árvores. Pensando na definição de regressão não-paramétrica, o modelo é dado por:</p>
<p><span class="math display">\[ y_i = r(x_i) + \epsilon_{i} = \sum_{j=1}^{q}tree_j(x_i) + \epsilon_{i}\]</span></p>
<p>Onde cada árvore <span class="math inline">\(tree_j\)</span> foi treinada sequencialmente.</p>
<p>Em python, o modelo treinado acima pode ser modelado como:</p>
<div id="cell-11" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>x_space <span class="op">=</span> np.arange(<span class="op">-</span><span class="dv">5</span>, <span class="dv">6</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> <span class="bu">sum</span>(tree.predict(x_space) <span class="cf">for</span> tree <span class="kw">in</span> (tree_1, tree_2, tree_3))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Visualizando o modelo:</p>
<div id="cell-13" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>ax.scatter(x<span class="op">=</span>X, </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>           y<span class="op">=</span>y, </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>           color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>ax.plot(x_space, y_pred, label<span class="op">=</span><span class="st">"GBDT"</span>, color<span class="op">=</span><span class="st">"g"</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>plt.plot(x_space, x_space <span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">5</span>, label<span class="op">=</span><span class="st">"Modelo Gerador"</span>, color<span class="op">=</span><span class="st">"b"</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Gradient Boosting Decision Tree"</span>) </span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Um ponto de atenção desses modelos está na <b>extrapolação do espaço das covariáveis</b>. Como esses modelos, os não-paramétricos, ““perseguem”” os dados, geralmente possuem uma performance péssima quando usados para a extrapolação dos dados de treinamento. Além disso, por serem baseados em Árvores de Decisão, são construídos baseados em “quebras” do dataset (nós), o que acentua esse problema de extrapolação.</p>
<p>No exemplo abaixo, usamos o mesmo modelo, que foi treinado com dados entre 5 e -5 para prever valores além desse espaço:</p>
<div id="cell-15" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>x_space <span class="op">=</span> np.arange(<span class="op">-</span><span class="dv">7</span>, <span class="dv">8</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> <span class="bu">sum</span>(tree.predict(x_space) <span class="cf">for</span> tree <span class="kw">in</span> (tree_1, tree_2, tree_3))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-16" class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>ax.scatter(x<span class="op">=</span>X, </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>           y<span class="op">=</span>y, </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>           color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>ax.plot(x_space, y_pred, label<span class="op">=</span><span class="st">"GBDT"</span>, color<span class="op">=</span><span class="st">"g"</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>plt.plot(x_space, x_space <span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">5</span>, label<span class="op">=</span><span class="st">"Modelo Gerador"</span>, color<span class="op">=</span><span class="st">"b"</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>x_lim, y_lim <span class="op">=</span> plt.xlim(), plt.ylim()</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>plt.fill_betweenx(y_lim, <span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>, color<span class="op">=</span><span class="st">"g"</span>, alpha<span class="op">=</span><span class="fl">.1</span>, label<span class="op">=</span><span class="st">"Espaço de Treino"</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>plt.fill_betweenx(y_lim, x_lim[<span class="dv">0</span>], <span class="op">-</span><span class="dv">5</span>, color<span class="op">=</span><span class="st">"r"</span>, alpha<span class="op">=</span><span class="fl">.1</span>, label<span class="op">=</span><span class="st">"Extrapolação"</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>plt.fill_betweenx(y_lim, <span class="dv">5</span>, x_lim[<span class="dv">1</span>], color<span class="op">=</span><span class="st">"r"</span>, alpha<span class="op">=</span><span class="fl">.1</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>plt.xlim(x_lim), plt.ylim(y_lim)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Gradient Boosting Decision Tree"</span>) </span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Como pode ser visto, o modelo perde performance nessa extrapolação. Na verdade, a previsão do modelo se torna somente uma continuação da última previsão dentro do espaço de covariáveis. No caso, provavelmente o modelo definiu algo como “if x &gt;= 4.5 then 25” e aplicou essa regra para a extrapolação.</p>
<p>Esse não é somente um problema dos modelos baseados em árvores: modelos de aprendizado de máquina só aprendem o que são ensinados e suas extrapolações são sempre limitadas. Sejam regressões lineares, sejam redes neurais.</p>
<p>A partir de agora será usado o XGBoost sem tunagem de hiper-parâmetros, dado que a idéia é apenas entender sua aplicação em séries temporais.</p>
</section>
<section id="modelando-xgboost-vs-regressão-linear-para-previsão-de-demanda" class="level2">
<h2 class="anchored" data-anchor-id="modelando-xgboost-vs-regressão-linear-para-previsão-de-demanda">Modelando: XGBoost vs Regressão Linear para Previsão de Demanda</h2>
<section id="baixando-os-dados" class="level3">
<h3 class="anchored" data-anchor-id="baixando-os-dados">Baixando os dados:</h3>
<p>Os dados de demanda de Cerveja, Vinhos e Liquor no USA podem ser acessados <a href="https://raw.githubusercontent.com/flo7up/relataly_data/main/alcohol_sales/BeerWineLiquor.csv">aqui</a>.</p>
<div id="cell-19" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/flo7up/relataly_data/main/alcohol_sales/BeerWineLiquor.csv"</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(path, </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                 parse_dates<span class="op">=</span>[<span class="st">"date"</span>]).set_index(<span class="st">"date"</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>df.tail()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="48">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">beer</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">2018-08-01</td>
<td>4898</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2018-09-01</td>
<td>4598</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2018-10-01</td>
<td>4737</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2018-11-01</td>
<td>5130</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2018-12-01</td>
<td>6370</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="cell-20" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>plt.plot(df.beer, <span class="st">'k'</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Beer Sales"</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-metodologia" class="level3">
<h3 class="anchored" data-anchor-id="sec-metodologia">Metodologia:</h3>
<p>A idéia da análise é fazer um comparativo de desempenho conforme se aumenta a sofisticação do XGBoost. Serão feitas validações cruzadas onde o objetivo do modelo será prever a demanda do ano seguinte. Serão usados 72 meses para prever a demanda total dos próximos 12, como pode ser visto abaixo:</p>
<div id="cell-22" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>tscv <span class="op">=</span> TimeSeriesSplit(n_splits<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                       max_train_size<span class="op">=</span><span class="dv">72</span>,</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                       test_size<span class="op">=</span><span class="dv">12</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                       )</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>tscv_generator <span class="op">=</span> tscv.split(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-23" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(<span class="bu">list</span>(tscv.split(df)))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>f, axs <span class="op">=</span> plt.subplots(nrows<span class="op">=</span>n,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                      ncols<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                      sharex<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                      figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">8</span>))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>f.suptitle(<span class="ss">f"Cross-Validation Subsets (</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (train_index, test_index) <span class="kw">in</span> <span class="bu">enumerate</span>(tscv.split(df)):</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    axs[i].plot(df.iloc[train_index], <span class="st">'k'</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    axs[i].plot(df.iloc[test_index], <span class="st">'r'</span>)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    axs[i].get_yaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-12-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="modelando-tendência" class="level3">
<h3 class="anchored" data-anchor-id="modelando-tendência">Modelando Tendência</h3>
<p>É bem nítido que há uma tendência na série. Isso é, intrisicamente no Processo Estocástico (PE) gerador da série há alguma função do tempo que, sistematicamente, soma algum incremento na série, multiplique ela por um fator &gt; 1 ou faça ambos ao mesmo tempo.</p>
<div id="cell-26" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>plt.plot(df.beer.resample(<span class="st">'1YE'</span>).<span class="bu">sum</span>(), <span class="st">'k'</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"beer Sales"</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Por uma questão de simplicidade de modelo, será usado uma relação linear para descrever essa suposta função. O modelo da demanda no caso da regressão linear será:</p>
<p><span class="math display">\[y_t = \beta_0 + \beta_{trend}t\]</span></p>
<p>A interpretação dos parâmetros <span class="math inline">\(\beta_0\)</span> e <span class="math inline">\(\beta_{trend}\)</span> é bem intuitiva. Como o input é o ano do modelo, <span class="math inline">\(\beta_{trend}\)</span> é a variação média anual e o <span class="math inline">\(\beta_{0}\)</span> a “demanda inicial” no ano 0 (sim, não faz sentido e é bem comum). No caso, não tem como saber exatamente como será o modelo do XGBoost e a vantagem dessa classe de modelos é exatamente essa. Por se tratar de uma regressão não-paramétrica, ele encontrará, nos dados, a melhor forma de descrever essa tendência em função do tempo.</p>
<p>Criando uma função para automatizar o processo de data featuring para a tendência:</p>
<div id="cell-28" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> data_featuring_trend(df):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> df.copy()</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    X.loc[:, <span class="st">'ano'</span>] <span class="op">=</span> [i.year <span class="cf">for</span> i <span class="kw">in</span> X.index]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X.drop(labels<span class="op">=</span>[<span class="st">'beer'</span>],</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>                   axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Criando o modelo para os 20 backtest:</p>
<div id="cell-30" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>cv_generator <span class="op">=</span> tscv.split(df)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>acc_reg_1 <span class="op">=</span> []</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>acc_xgb_1 <span class="op">=</span> []</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (train_index, test_index) <span class="kw">in</span> <span class="bu">enumerate</span>(tscv.split(df.beer.values)):</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Separando teste do treino</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    y_train <span class="op">=</span> df.iloc[train_index].copy()</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    X_train <span class="op">=</span> data_featuring_trend(y_train)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    y_test <span class="op">=</span> df.iloc[test_index].copy()</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    X_test <span class="op">=</span> data_featuring_trend(y_test)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Treinando modelos</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    reg <span class="op">=</span> LinearRegression(fit_intercept<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    reg.fit(X_train.values, y_train)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    y_reg_pred <span class="op">=</span> reg.predict(X<span class="op">=</span>X_test.values)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    xgb <span class="op">=</span> XGBRegressor()</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    xgb.fit(X_train.values, y_train.values.ravel())</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    y_xgb_pred <span class="op">=</span> xgb.predict(X<span class="op">=</span>X_test.values)</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Salvando acurácia dos modelos</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    acc_reg_1.append(<span class="dv">1</span><span class="op">-</span><span class="bu">abs</span>(y_test.beer.values.<span class="bu">sum</span>()<span class="op">-</span> y_reg_pred.<span class="bu">sum</span>())<span class="op">/</span>y_test.beer.values.<span class="bu">sum</span>())</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    acc_xgb_1.append(<span class="dv">1</span><span class="op">-</span><span class="bu">abs</span>(y_test.beer.values.<span class="bu">sum</span>()<span class="op">-</span> y_xgb_pred.<span class="bu">sum</span>())<span class="op">/</span>y_test.beer.values.<span class="bu">sum</span>())</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>acc_reg_1,acc_xgb_1 <span class="op">=</span> np.array(acc_reg_1), np.array(acc_xgb_1)</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(acc_reg_1)</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(acc_xgb_1)</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"XGBoost vence: </span><span class="sc">{</span>(acc_xgb_1<span class="op">&gt;</span>acc_reg_1)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span><span class="bu">round</span>(<span class="dv">100</span><span class="op">*</span>(acc_xgb_1<span class="op">&gt;</span>acc_reg_1).mean(), <span class="dv">2</span>)<span class="sc">}</span><span class="ss"> %)"</span>)</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"regressão vence: </span><span class="sc">{</span>(acc_xgb_1<span class="op">&lt;</span>acc_reg_1)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span><span class="bu">round</span>(<span class="dv">100</span><span class="op">*</span>(acc_xgb_1<span class="op">&lt;</span>acc_reg_1).mean(), <span class="dv">2</span>)<span class="sc">}</span><span class="ss"> %)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0.96975878 0.95273909 0.9895277  0.96724426 0.95933134 0.996359
 0.98306074 0.94584999 0.95548503 0.9947364  0.96824616 0.97035176
 0.97464616 0.98857959 0.97895506 0.97236466 0.97753643 0.97691234
 0.9985189  0.99684608]

[0.95867934 0.92875407 0.96239128 0.99086754 0.98112817 0.94656535
 0.95894754 0.93200233 0.94460743 0.96516789 0.98158768 0.97207787
 0.97662276 0.95552783 0.96286553 0.95423104 0.95521251 0.94920657
 0.96978884 0.95652298]

XGBoost vence: 5 (25.0 %)

regressão vence: 15 (75.0 %)</code></pre>
</div>
</div>
<p>Como pode ser visto, o XGBoost perfoma acima da regressão linear em somente 5 de 20 casos (25%).</p>
<div id="cell-32" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="dv">1</span>, <span class="bu">len</span>(acc_xgb_1) <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>ax.plot(x, acc_xgb_1, <span class="st">'bo-'</span>, label<span class="op">=</span><span class="st">'XGBoost'</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>ax.plot(x, acc_reg_1, <span class="st">'go-'</span>, label<span class="op">=</span><span class="st">'regressão'</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>ax.axhline(y<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'k'</span>, ls<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">.3</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Rodada"</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Acurácia"</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="fl">.8</span>, <span class="fl">1.1</span>)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">.5</span>, ls<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>plt.legend(frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>plt.xticks(np.arange(<span class="dv">0</span>, <span class="dv">22</span>, <span class="dv">2</span>))</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Round"</span>)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Acurácia"</span>)</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Análise de Performance"</span>)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">False</span>)</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-16-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Mas afinal, o que a regressão linear entendeu que o XGBoost não entendeu? O que pode explicar esse melhor desempenho do modelo mais simples?</p>
<p>Para responder essa questão, o próximo passo é explorar pelo menos o último modelo treinado e entender o que aconteceu.</p>
<div id="cell-34" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train, <span class="st">'k'</span>, label<span class="op">=</span><span class="st">'Treino'</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test, <span class="st">'r--'</span>, label<span class="op">=</span><span class="st">'Teste'</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test.index, y_xgb_pred, <span class="st">'b--'</span>, label<span class="op">=</span><span class="st">'xgboost'</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train.index, xgb.predict(X<span class="op">=</span>X_train.values), <span class="st">'b'</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test.index, y_reg_pred, <span class="st">'g--'</span>, label<span class="op">=</span><span class="st">'Regressão'</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train.index, reg.predict(X<span class="op">=</span>X_train.values), <span class="st">'g'</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Série Temporal"</span>)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Fazendo um gráfico de dispersão das observações da série em termos das variáveis de entrada (ano):</p>
<div id="cell-36" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train.index.year, y_train, <span class="st">'ko'</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test.index.year, y_test, <span class="st">'ro'</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train.index.year.to_list()<span class="op">+</span>[y_test.index[<span class="dv">0</span>].year], <span class="bu">list</span>(xgb.predict(X<span class="op">=</span>X_train.values)) <span class="op">+</span> [y_xgb_pred[<span class="dv">0</span>]], <span class="st">'b--'</span>, label<span class="op">=</span><span class="st">"XGBoost"</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train.index.year.to_list() <span class="op">+</span> [y_test.index.year[<span class="dv">0</span>]], <span class="bu">list</span>(reg.predict(X<span class="op">=</span>X_train.values)) <span class="op">+</span> [y_reg_pred[<span class="dv">0</span>]], <span class="st">'g--'</span>, label<span class="op">=</span><span class="st">"Regressão"</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>ylim, xlim <span class="op">=</span> plt.ylim(), plt.xlim()</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>plt.fill_betweenx(ylim, xlim[<span class="dv">0</span>], <span class="fl">2017.5</span>, alpha<span class="op">=</span><span class="fl">.1</span>, label<span class="op">=</span><span class="st">"Espaço de Treinamento"</span>, color<span class="op">=</span><span class="st">"g"</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>plt.fill_betweenx(ylim, <span class="fl">2017.5</span>, xlim[<span class="op">-</span><span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">.1</span>, label<span class="op">=</span><span class="st">"Extrapolação"</span>, color<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>plt.ylim(ylim), plt.xlim(xlim)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Previsão Condicional"</span>)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Covariável Ano"</span>)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-18-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>O primeiro ponto é quanto a previsão “linear”. Sim, naturalmente a previsão vai ser uma reta horizontal. Dado que em todos os 12 pontos do ano há o mesmo input (o ano corrente). Ao longo do texto essa previsão se tornará mais sofisticada.</p>
<p>O segundo ponto é a fraquíssima capacidade do XGBoost em extrapolar a previsão para fora do espaço de treino das covariáveis. Bom, isso não é exatamente um problema exclusivo do XGBoost. E isso também já foi abordado no começo do texto.</p>
<p>A regressão linear também sofre com isso. Inclusive, quando se aprende regressão linear, aprende-se que deve-se evitar essa extrapolação. E, nesse caso, performou melhor por ser mais simples. É um modelo que apenas estima a varição ano a ano média, o que foi o suficiente pra performar acima do XGBoost (que basicamente supôs um crescimento zero).</p>
<p>Analisando as nuances do teste, o que foi feito, em termos práticos, foi ensinar um modelo o padrão da demanda entre os inputs de 2012 a 2017. No entanto, o que foi exigido foi prever como vai ser essa demanda em 2018. Parece até sacanagem com o coitado. De fato, ele entendeu a demanda nos dados de treino, mas a falta de observações do futuro não permitiu ele entender o seu comportamento.</p>
<p>Por hora, fica no radar essa eventual limitação no que tange ao intervalo de predição.</p>
</section>
<section id="modelando-a-sazonalidade" class="level3">
<h3 class="anchored" data-anchor-id="modelando-a-sazonalidade">Modelando a Sazonalidade:</h3>
<p>A série tem um claro fator sazonal que pode ser observado na vizualização abaixo:</p>
<div id="cell-39" class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> df.index.year.unique():</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    df_temp <span class="op">=</span> df.loc[df.index.year <span class="op">==</span> year]</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    ax.plot(df_temp.index.month, df_temp.beer, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Mês"</span>)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"beer Sales (Mês)"</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-19-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>E, agora, que já há uma previsão da tendência, o próximo passo é saber o quanto a demanda vai variar em cada mês em relação ao “nível” médio anual. Dessa forma, o modelo de regressão linear ganha essa cara:</p>
<p><span class="math display">\[y_{t} = \beta_{0} + \beta_{trend}t + \beta_{jan}x_{jan} + \beta_{fev}x_{fev}+ ... + \beta_{nov}x_{nov}\]</span></p>
<p>Onde as variáveis <span class="math inline">\(x_{k}'s\)</span> são variáveis binárias que correspondem ao mês. Isso é, <span class="math inline">\(x_{jan}\)</span> vale 1 se o mês for janeiro, 0 caso contrário. E, portanto, <span class="math inline">\(\beta_{jan}\)</span> é o “prêmio” que se soma a demanda por ser janeiro, podendo ser positivo ou não. O input da regressão linear DEVE ser feito via variáveis dummies, dado que o mês é uma variável qualitativa nominal e o modelo é linear. Não há dezembro nas variáveis dummies por uma questão de multicolinearidade (o intercepto seria uma relação linear perfeita de todas as variáveis de sazonalidade).</p>
<p>Novamente, não é possível saber como o XGBoost vai ser interpretado, dado que trata-se de uma regressão não-paramétrica. O input da sazonalidade PODE ser dado como se o mês fosse uma variável numérica, dado que o modelo é baseado em árvores de decisão e conseguiria “captar” o movimento da sazonalidade. No entanto, será usado, também, variáveis dummies.</p>
<p>Criando funções que adicionam variáveis de sazonalidade:</p>
<div id="cell-41" class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> data_featuring_sazo(df):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> df.copy()</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    X.loc[:, <span class="st">'year'</span>] <span class="op">=</span> [i.year <span class="cf">for</span> i <span class="kw">in</span> X.index]</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    X.loc[:, <span class="st">'month'</span>] <span class="op">=</span> [i.month <span class="cf">for</span> i <span class="kw">in</span> X.index]</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    X_sazo <span class="op">=</span> pd.get_dummies(X[<span class="st">'month'</span>]).astype(<span class="st">"category"</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> pd.concat([X, X_sazo], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X.drop(labels<span class="op">=</span>[<span class="st">'month'</span>, <span class="st">'beer'</span>, <span class="dv">12</span>],</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span><span class="dv">1</span>).astype(<span class="st">'int'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Vizualizando quais seriam os inputs:</p>
<div id="cell-43" class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>data_featuring_sazo(df.iloc[<span class="op">-</span><span class="dv">12</span>:])<span class="op">\</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>                   .reset_index(drop<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="60">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">year</th>
<th data-quarto-table-cell-role="th">1</th>
<th data-quarto-table-cell-role="th">2</th>
<th data-quarto-table-cell-role="th">3</th>
<th data-quarto-table-cell-role="th">4</th>
<th data-quarto-table-cell-role="th">5</th>
<th data-quarto-table-cell-role="th">6</th>
<th data-quarto-table-cell-role="th">7</th>
<th data-quarto-table-cell-role="th">8</th>
<th data-quarto-table-cell-role="th">9</th>
<th data-quarto-table-cell-role="th">10</th>
<th data-quarto-table-cell-role="th">11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2018</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2018</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">9</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">10</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">11</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Criando o modelo para os 20 backtests:</p>
<div id="cell-45" class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>cv_generator <span class="op">=</span> tscv.split(df)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>acc_reg_2 <span class="op">=</span> []</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>acc_xgb_2 <span class="op">=</span> []</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (train_index, test_index) <span class="kw">in</span> <span class="bu">enumerate</span>(tscv.split(df.beer.values)):</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Separando teste do treino</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    y_train <span class="op">=</span> df.iloc[train_index].copy()</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    X_train <span class="op">=</span> data_featuring_sazo(y_train)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    y_test <span class="op">=</span> df.iloc[test_index].copy()</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    X_test <span class="op">=</span> data_featuring_sazo(y_test)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Treinando modelos</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    reg <span class="op">=</span> LinearRegression(fit_intercept<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    reg.fit(X_train.values, y_train)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    y_reg_pred <span class="op">=</span> reg.predict(X<span class="op">=</span>X_test.values)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    xgb <span class="op">=</span> XGBRegressor()</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    xgb.fit(X_train.values, y_train.values.ravel())</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    y_xgb_pred <span class="op">=</span> xgb.predict(X_test.values)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Salvando acurácia dos modelos</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    acc_reg_2.append(<span class="dv">1</span><span class="op">-</span><span class="bu">abs</span>(y_test.beer.values.<span class="bu">sum</span>()<span class="op">-</span> y_reg_pred.<span class="bu">sum</span>())<span class="op">/</span>y_test.beer.values.<span class="bu">sum</span>())</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    acc_xgb_2.append(<span class="dv">1</span><span class="op">-</span><span class="bu">abs</span>(y_test.beer.values.<span class="bu">sum</span>()<span class="op">-</span> y_xgb_pred.<span class="bu">sum</span>())<span class="op">/</span>y_test.beer.values.<span class="bu">sum</span>())</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>acc_reg_2,acc_xgb <span class="op">=</span> np.array(acc_reg_2), np.array(acc_xgb_2)</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(acc_reg_2)</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(acc_xgb)</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"XGBoost vence: </span><span class="sc">{</span>(acc_xgb<span class="op">&gt;</span>acc_reg_2)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span><span class="bu">round</span>(<span class="dv">100</span><span class="op">*</span>(acc_xgb<span class="op">&gt;</span>acc_reg_2).mean(), <span class="dv">2</span>)<span class="sc">}</span><span class="ss"> %)"</span>)</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"regressão vence: </span><span class="sc">{</span>(acc_xgb<span class="op">&lt;</span>acc_reg_2)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span><span class="bu">round</span>(<span class="dv">100</span><span class="op">*</span>(acc_xgb<span class="op">&lt;</span>acc_reg_2).mean(), <span class="dv">2</span>)<span class="sc">}</span><span class="ss"> %)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0.96975878 0.95273909 0.9895277  0.96724426 0.95933134 0.996359
 0.98306074 0.94584999 0.95548503 0.9947364  0.96824616 0.97035176
 0.97464616 0.98857959 0.97895506 0.97236466 0.97753643 0.97691234
 0.9985189  0.99684608]

[0.95846651 0.92909444 0.96159648 0.99043659 0.98197803 0.94585835
 0.95772977 0.93218758 0.94337105 0.96446503 0.98153546 0.97121937
 0.9757154  0.95458422 0.96269496 0.95324182 0.95416837 0.9484232
 0.96875804 0.9556873 ]

XGBoost vence: 5 (25.0 %)

regressão vence: 15 (75.0 %)</code></pre>
</div>
</div>
<p>E o XGBoost segue performando ABAIXO da regressão linear. Dando uma explorada na forma com que ele lidou com os dados:</p>
<div id="cell-47" class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train, <span class="st">'k'</span>, label<span class="op">=</span><span class="st">'Treino'</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test, <span class="st">'r--'</span>, label<span class="op">=</span><span class="st">'Teste'</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test.index, y_xgb_pred, <span class="st">'b--'</span>, label<span class="op">=</span><span class="st">'xgboost'</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train.index, xgb.predict(X<span class="op">=</span>X_train.values), <span class="st">'b'</span>)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test.index, y_reg_pred, <span class="st">'g--'</span>, label<span class="op">=</span><span class="st">'Regressão'</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train.index, reg.predict(X<span class="op">=</span>X_train.values), <span class="st">'g'</span>)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>plt.legend(frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Série Temporal"</span>)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-23-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>O XGBoost parece entender o padrão nos dados de treino, mas performa mal nos dados de teste. O mais natural seria imaginar um cenário de overfitting e optar pela “simplificação” do modelo, mas nesse caso o buraco é mais embaixo. A falta de performance está relacionada com a incapacidade de prever a variável <span class="math inline">\(y_t\)</span> quando a covariável ano tem valor igual a 2018 (novamente, a questão da extrapolação). Sim, é overfitting. O modelo “repetiu” os dados de treinamento, todavia, isso está mais relacionado a covariáveis do que necessariamente complexidade do modelo.</p>
<p>Plotando a previsão sob as covariáveis:</p>
<div id="cell-49" class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train.index.year, y_train, <span class="st">'ko'</span>, label<span class="op">=</span><span class="st">'Treino'</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test.index.year, y_test, <span class="st">'ro'</span>, label<span class="op">=</span><span class="st">'Teste'</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>xgb_model <span class="op">=</span> <span class="bu">list</span>(xgb.predict(X<span class="op">=</span>X_train.values)) <span class="op">+</span> <span class="bu">list</span>(y_xgb_pred)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>xgb_model <span class="op">=</span> pd.Series(xgb_model,</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>                      index<span class="op">=</span>X_train.index.year.to_list()<span class="op">+</span>X_test.index.year.to_list())</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>plt.plot(xgb_model.groupby(level<span class="op">=</span><span class="dv">0</span>).mean(), <span class="st">'b--o'</span>, label<span class="op">=</span><span class="st">'xgboost'</span>)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>reg_model <span class="op">=</span> <span class="bu">list</span>(reg.predict(X<span class="op">=</span>X_train.values)) <span class="op">+</span> <span class="bu">list</span>(y_reg_pred)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>reg_model <span class="op">=</span> pd.Series(reg_model,</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>                      index<span class="op">=</span>X_train.index.year.to_list()<span class="op">+</span>X_test.index.year.to_list())</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>plt.plot(reg_model.groupby(level<span class="op">=</span><span class="dv">0</span>).mean(), <span class="st">'g--o'</span>, label<span class="op">=</span><span class="st">'Regressão'</span>)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>ylim, xlim <span class="op">=</span> plt.ylim(), plt.xlim()</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>plt.fill_betweenx(ylim, xlim[<span class="dv">0</span>], <span class="fl">2017.5</span>, alpha<span class="op">=</span><span class="fl">.1</span>, label<span class="op">=</span><span class="st">"Espaço de Treinamento"</span>, color<span class="op">=</span><span class="st">"g"</span>)</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>plt.fill_betweenx(ylim, <span class="fl">2017.5</span>, xlim[<span class="op">-</span><span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">.1</span>, label<span class="op">=</span><span class="st">"Extrapolação"</span>, color<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>plt.ylim(ylim), plt.xlim(xlim)</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Covariável Ano"</span>)</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>plt.legend(frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Previsão Condicionada"</span>)</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-24-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Como pode ser visto, a previsão média do modelo XGBoost para a covariável 2018 foi idêntica a sua previsão para covariável 2017, a mais próxima dentro do espaço de treinamento. Novamente, overfitting, mas não qualquer overfitting. A simplificação do modelo NÃO vai gerar ganho de performance nesse caso.</p>
<p>Analisando a covariável mês:</p>
<div id="cell-51" class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> y_train.index.year.unique():</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    df_temp <span class="op">=</span> y_train.loc[y_train.index.year <span class="op">==</span> year]</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    ax.plot(df_temp.index.month, df_temp.beer, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>ax.plot(y_test.index.month, y_xgb_pred, <span class="st">'b--'</span>, label<span class="op">=</span><span class="st">'XGBoost'</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>ax.plot(y_test.index.month, y_reg_pred, <span class="st">'g--'</span>, label<span class="op">=</span><span class="st">'Regressão'</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>ax.plot(y_test.index.month, y_test, <span class="st">'r--'</span>, label<span class="op">=</span><span class="st">'Teste'</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Covariável Mês"</span>)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"beer Sales (Mês)"</span>)</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-25-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Nesse caso, a previsão sob as covariáveis do mês parece estar exatamente sobre o ano anterior. A sobreposição com o provável ano 2017 indica que a tendência dos dados forçou o modelo apenas a repetir a previsão passada por estar “navegando” no escuro (extrapolando as covariáveis).</p>
<p>Se abríssemos a caixa do modelo, provavelmente teríamos as primeiras árvores como:</p>
<p>“if ano &gt;= 2017 and março=1 then 4268.36”</p>
<div id="cell-53" class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Gerando amostras para evidênciar ponto</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>df_test <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>pd.date_range(<span class="st">"2017-03-01"</span>, <span class="st">"2025-12-01"</span>, freq<span class="op">=</span><span class="st">"1ME"</span>),</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>                       columns<span class="op">=</span>[<span class="st">"beer"</span>])</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Gerando features</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>df_test <span class="op">=</span> data_featuring_sazo(df_test)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Pegando só março</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>df_test <span class="op">=</span> df_test.loc[df_test[<span class="dv">3</span>]<span class="op">==</span><span class="dv">1</span>]</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>df_test.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">year</th>
<th data-quarto-table-cell-role="th">1</th>
<th data-quarto-table-cell-role="th">2</th>
<th data-quarto-table-cell-role="th">3</th>
<th data-quarto-table-cell-role="th">4</th>
<th data-quarto-table-cell-role="th">5</th>
<th data-quarto-table-cell-role="th">6</th>
<th data-quarto-table-cell-role="th">7</th>
<th data-quarto-table-cell-role="th">8</th>
<th data-quarto-table-cell-role="th">9</th>
<th data-quarto-table-cell-role="th">10</th>
<th data-quarto-table-cell-role="th">11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">2017-03-31</td>
<td>2017</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2018-03-31</td>
<td>2018</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2019-03-31</td>
<td>2019</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2020-03-31</td>
<td>2020</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2021-03-31</td>
<td>2021</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="cell-54" class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(xgb.predict(df_test.values))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[4268.36 4268.36 4268.36 4268.36 4268.36 4268.36 4268.36 4268.36 4268.36]</code></pre>
</div>
</div>
<div id="cell-55" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>y_train.loc[<span class="st">"2017-03-01"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="67">
<pre><code>beer    4247
Name: 2017-03-01 00:00:00, dtype: int64</code></pre>
</div>
</div>
<p>Nesse caso, o dado de treino de março de 2017 era <span class="math inline">\(4247\)</span>. A previsão para esse mês no modelo foi <span class="math inline">\(4268\)</span>. Nada mal, um erro de <span class="math inline">\(0.49\%\)</span>. O ponto é que o modelo aplicou essa regra para todos os anos seguintes, o que gerou praticamente um naive-forecast. Isso porque, novamente, por ser um modelo constrúido baseado em árvores, em algum momento definiu a dita regra:</p>
<p>“if ano &gt;= 2017 and março=1 then 4268.36”</p>
<p>Que, sim, é válida para 2017, mas inútil para os anos seguintes.</p>
</section>
</section>
<section id="removendo-tendência" class="level2">
<h2 class="anchored" data-anchor-id="removendo-tendência">Removendo Tendência:</h2>
<p>Será feito uma transformação na variável <span class="math inline">\(y_t\)</span> a fim de que a previsão dela seja “facilitada” para os modelos.</p>
<div id="cell-59" class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>ax.plot(df.diff().dropna()[<span class="st">'beer'</span>], <span class="st">'k'</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Variação Nominal"</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-29-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>A série continua, ainda, não estacionária, posto que sua variância aumenta em função do tempo. A gente pode remover essa heterocedasticidade usando o logaritmo da série (e o derivando, dado que ele também não é estacionário):</p>
<div id="cell-61" class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>ax.plot((np.log(df[<span class="st">'beer'</span>])).diff().dropna(), <span class="st">'k'</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Variação Nominal do Logaritmo"</span>)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-30-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Neste caso, a série passa a se comportar de forma estacionária. Rodando os modelos novamente e removendo a covariável ano (que nesse caso não trará mais nenhuma informação, posto que não há mais tendência):</p>
<div id="cell-63" class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>acc_reg_3 <span class="op">=</span> []</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>acc_xgb_3 <span class="op">=</span> []</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (train_index, test_index) <span class="kw">in</span> <span class="bu">enumerate</span>(tscv.split(df.beer.values)):</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Separando teste do treino</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    y_train <span class="op">=</span> df.iloc[train_index].copy()</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    y_test <span class="op">=</span> df.iloc[test_index].copy()</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fazendo a transformação</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    df_temp <span class="op">=</span> np.log(pd.concat([y_train, y_test])).diff().dropna()</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    y_train, y_test <span class="op">=</span> df_temp.loc[y_train.index[<span class="dv">1</span>:]], df_temp.loc[y_test.index]</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    X_train <span class="op">=</span> data_featuring_sazo(y_train).drop(labels<span class="op">=</span>[<span class="st">"year"</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    X_test <span class="op">=</span> data_featuring_sazo(y_test).drop(labels<span class="op">=</span>[<span class="st">"year"</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Treinando modelos</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    reg <span class="op">=</span> LinearRegression(fit_intercept<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    reg.fit(X_train.values, y_train)</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    y_reg_pred <span class="op">=</span> reg.predict(X<span class="op">=</span>X_test.values)</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>    xgb <span class="op">=</span> XGBRegressor()</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>    xgb.fit(X_train.values, y_train)</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>    y_xgb_pred <span class="op">=</span> xgb.predict(X<span class="op">=</span>X_test.values)</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Retornando as variáveis para escala padrão (integrando):</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>    y_test <span class="op">=</span> np.array([<span class="dv">0</span>] <span class="op">+</span> <span class="bu">list</span>(y_train.beer.values) <span class="op">+</span> <span class="bu">list</span>(y_test.beer.values))</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>    y_test <span class="op">=</span> np.exp(np.log(df.iloc[train_index[<span class="dv">0</span>], <span class="dv">0</span>]) <span class="op">+</span> y_test.cumsum())[<span class="op">-</span><span class="dv">12</span>:]</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>    y_reg_pred <span class="op">=</span> np.array([<span class="dv">0</span>] <span class="op">+</span> <span class="bu">list</span>(reg.predict(X<span class="op">=</span>X_train.values)[:,<span class="dv">0</span>]) <span class="op">+</span> <span class="bu">list</span>(y_reg_pred[:,<span class="dv">0</span>]))</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>    y_reg_pred <span class="op">=</span> np.exp(np.log(df.iloc[train_index[<span class="dv">0</span>], <span class="dv">0</span>]) <span class="op">+</span> y_reg_pred.cumsum())</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>    y_xgb_pred <span class="op">=</span> np.array([<span class="dv">0</span>] <span class="op">+</span> <span class="bu">list</span>(xgb.predict(X<span class="op">=</span>X_train.values)) <span class="op">+</span> <span class="bu">list</span>(y_xgb_pred))</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>    y_xgb_pred <span class="op">=</span> np.exp(np.log(df.iloc[train_index[<span class="dv">0</span>], <span class="dv">0</span>]) <span class="op">+</span> y_xgb_pred.cumsum())</span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Salvando acurácia dos modelos</span></span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>    acc_reg_3.append(<span class="dv">1</span><span class="op">-</span><span class="bu">abs</span>(y_test.<span class="bu">sum</span>() <span class="op">-</span> y_reg_pred[<span class="op">-</span><span class="dv">12</span>:].<span class="bu">sum</span>())<span class="op">/</span>y_test.<span class="bu">sum</span>())</span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a>    acc_xgb_3.append(<span class="dv">1</span><span class="op">-</span><span class="bu">abs</span>(y_test.<span class="bu">sum</span>()<span class="op">-</span> y_xgb_pred[<span class="op">-</span><span class="dv">12</span>:].<span class="bu">sum</span>())<span class="op">/</span>y_test.<span class="bu">sum</span>())</span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true" tabindex="-1"></a>acc_reg_3,acc_xgb_3 <span class="op">=</span> np.array(acc_reg_3), np.array(acc_xgb_3)</span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(acc_reg_3)</span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(acc_xgb_3)</span>
<span id="cb34-48"><a href="#cb34-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb34-49"><a href="#cb34-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"XGBoost vence: </span><span class="sc">{</span>(acc_xgb_3<span class="op">&gt;</span>acc_reg_3)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span><span class="bu">round</span>(<span class="dv">100</span><span class="op">*</span>(acc_xgb_3<span class="op">&gt;</span>acc_reg_3).<span class="bu">sum</span>()<span class="op">/</span>n, <span class="dv">2</span>)<span class="sc">}</span><span class="ss"> %)"</span>)</span>
<span id="cb34-50"><a href="#cb34-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb34-51"><a href="#cb34-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"regressão vence: </span><span class="sc">{</span>(acc_xgb_3<span class="op">&lt;</span>acc_reg_3)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span><span class="bu">round</span>(<span class="dv">100</span><span class="op">*</span>(acc_xgb_3<span class="op">&lt;</span>acc_reg_3).<span class="bu">sum</span>()<span class="op">/</span>n, <span class="dv">2</span>)<span class="sc">}</span><span class="ss"> %)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0.97791268 0.97532984 0.97926429 0.94699662 0.99840119 0.97844555
 0.98353859 0.99307375 0.96906145 0.97516495 0.97668471 0.98575403
 0.99092345 0.99486025 0.99371951 0.97727946 0.99044558 0.99114195
 0.99404961 0.99367974]

[0.96222437 0.95883562 0.96374524 0.93170607 0.98668968 0.99358349
 0.99841658 0.97806518 0.98381625 0.99018077 0.99136643 0.99930242
 0.99403646 0.99053868 0.97984574 0.99048867 0.99583566 0.99536321
 0.98065699 0.99360972]

XGBoost vence: 10 (50.0 %)

regressão vence: 10 (50.0 %)</code></pre>
</div>
</div>
<div id="cell-64" class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>ax.plot(acc_xgb_3, <span class="st">'b-o'</span>, label<span class="op">=</span><span class="st">'XGBoost'</span>)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>ax.plot(acc_reg_3, <span class="st">'g-o'</span>, label<span class="op">=</span><span class="st">'Regressão'</span>)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="fl">.8</span>, <span class="fl">1.1</span>)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">.5</span>, ls<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>plt.legend(frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>plt.xticks(np.arange(<span class="dv">0</span>,<span class="dv">22</span>,<span class="dv">2</span>))</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Round"</span>)</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Acurácia"</span>)</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Análise de Performance"</span>)</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">False</span>)</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-32-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Nesse caso, saímos de um “massacre” para um empate. Isso é, conseguimos empatar com uma regressão linear. O que não tira o mérito do XGBoost, afinal, por que não uma regressão linear? Além disso, podemos “chorar” argumentando que 5 das 10 vitórias da Regressão Linear foram nas primeiras amostras de dados. Isso é, o XGBoost performou melhor nas previsões mais recentes.</p>
<p>Todavia, como só foi modelada a sazonalidade, e de forma linear ainda, não havia porque um modelo não linear (o XGBoost) performar tão acima de um modelo linear. Talvez com a inclusão de outras features, como promoções, o XGBoost performaria bem acima da Regressão Linear.</p>
<p>Explorando o último modelo do XGBoost:</p>
<div id="cell-66" class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>y_train <span class="op">=</span> df.iloc[train_index].copy()</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>y_test <span class="op">=</span> df.iloc[test_index].copy()</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train, <span class="st">'k'</span>, label<span class="op">=</span><span class="st">'Treino'</span>)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test, <span class="st">'r--'</span>, label<span class="op">=</span><span class="st">'Teste'</span>)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test.index, y_xgb_pred[<span class="op">-</span><span class="dv">12</span>:], <span class="st">'b--'</span>, label<span class="op">=</span><span class="st">'XGBoost'</span>)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test.index, y_reg_pred[<span class="op">-</span><span class="dv">12</span>:], <span class="st">'g--'</span>, label<span class="op">=</span><span class="st">'Regressão'</span>)</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>plt.legend(frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Série Temporal"</span>)</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-33-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Analisando as previsões sob os espaços das covariáveis:</p>
<p><b>LEMBRANDO: O ANO NÃO É MAIS UMA COVARIÁVEL PRESENTE NO MODELO. </b></p>
<div id="cell-68" class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>plt.plot(y_train.index.year, y_train, <span class="st">'ko'</span>, label<span class="op">=</span><span class="st">'Treino'</span>)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>plt.plot(y_test.index.year, y_test, <span class="st">'ro'</span>, label<span class="op">=</span><span class="st">'Teste'</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>xgb_model <span class="op">=</span> pd.Series(y_xgb_pred[<span class="dv">1</span>:],</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>                      index<span class="op">=</span>X_train.index.year.to_list()<span class="op">+</span>X_test.index.year.to_list())</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>plt.plot(xgb_model.groupby(level<span class="op">=</span><span class="dv">0</span>).mean(), <span class="st">'b--o'</span>, label<span class="op">=</span><span class="st">'xgboost'</span>)</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>reg_model <span class="op">=</span> pd.Series(y_reg_pred[<span class="dv">1</span>:],</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>                      index<span class="op">=</span>X_train.index.year.to_list()<span class="op">+</span>X_test.index.year.to_list())</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>plt.plot(reg_model.groupby(level<span class="op">=</span><span class="dv">0</span>).mean(), <span class="st">'g--o'</span>, label<span class="op">=</span><span class="st">'Regressão'</span>)</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>ylim, xlim <span class="op">=</span> plt.ylim(), plt.xlim()</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>plt.fill_betweenx(ylim, xlim[<span class="dv">0</span>], <span class="fl">2017.5</span>, alpha<span class="op">=</span><span class="fl">.1</span>, label<span class="op">=</span><span class="st">"Espaço de Treinamento"</span>, color<span class="op">=</span><span class="st">"g"</span>)</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>plt.fill_betweenx(ylim, <span class="fl">2017.5</span>, xlim[<span class="op">-</span><span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">.1</span>, label<span class="op">=</span><span class="st">"Extrapolação"</span>, color<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>plt.ylim(ylim), plt.xlim(xlim)</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Covariável Ano"</span>)</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>plt.legend(frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Machine Learning"</span>)</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-34-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Nesse caso, apesar de NÃO haver a covariável ano no modelo, é nítido que o modelo aprende um padrão temporal. Um padrão que não foi explicitamente ensinado, afinal, seria impossível fazer isso. Ele aprendeu a relação temporal a partir de uma transformação nos dados.</p>
<p>Pode-se pensar em Modelos de ML como alunos com zero senso crítico. Nesse caso, não ensinamos sobre uma covariável que ele precisaria extrapolar, mas optams por dar uma matéria “mastigada” pra ele aprender.</p>
<p>Plotando sob a covariável Mês:</p>
<div id="cell-70" class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> y_train.index.year.unique():</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    df_temp <span class="op">=</span> y_train.loc[y_train.index.year <span class="op">==</span> year]</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    ax.plot(df_temp.index.month, df_temp.beer, color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>ax.plot(y_test.index.month, y_xgb_pred[<span class="op">-</span><span class="dv">12</span>:], <span class="st">'b--'</span>, label<span class="op">=</span><span class="st">'XGBoost'</span>)</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>ax.plot(y_test.index.month, y_reg_pred[<span class="op">-</span><span class="dv">12</span>:], <span class="st">'g--'</span>, label<span class="op">=</span><span class="st">'Regressão'</span>)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>ax.plot(y_test.index.month, y_test, <span class="st">'r--'</span>, label<span class="op">=</span><span class="st">'Teste'</span>)</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>)</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Covariável Mês"</span>)</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"beer Sales (Mês)"</span>)</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-35-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Novamente observa-se um aprendizado muito mais “autêntico” do modelo. Ele não repete a última previsão, mas cria a própria a partir de um padrão entendido nos dados.</p>
</section>
<section id="comentários-finais" class="level1">
<h1>Comentários Finais:</h1>
<p>O XGBoost, assim como o LGBM e outros modelos de ML, são bem promissores no contexto de séries temporais. A dor no seu uso resíde na má aplicação deles, que geralmente gira em torno de se esperar uma <i>Panaceia</i> de um modelo matemático. Modelos de ML possuem diversas limitações, extrapolação em covariáveis é uma delas.</p>
<p>Por exemplo, quando usamos o XGBoost com uma covariável que seria extrapolada, tivemos uma performance tosquíssima. A inclusão de novas features sequer melhorou o modelo. Sem um entendimento do que estava acontecendo, esses modelos provavelmente seriam descartados.</p>
<div id="cell-73" class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>f, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>ax.plot(acc_xgb_1, <span class="st">'b-o'</span>, alpha<span class="op">=</span><span class="fl">.5</span>, label<span class="op">=</span><span class="st">'XGBoost 1'</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>ax.plot(acc_xgb_2, <span class="st">'r-o'</span>, alpha<span class="op">=</span><span class="fl">.5</span>, label<span class="op">=</span><span class="st">'XGBoost 2'</span>)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>ax.plot(acc_xgb_3, <span class="st">'g-o'</span>, alpha<span class="op">=</span><span class="fl">.5</span>, label<span class="op">=</span><span class="st">'XGBoost 3'</span>)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="fl">.8</span>, <span class="fl">1.1</span>)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">.5</span>, ls<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>plt.legend(frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>plt.xticks(np.arange(<span class="dv">0</span>, <span class="dv">22</span>,<span class="dv">2</span>))</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Round"</span>)</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Acurácia"</span>)</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Análise de Performance"</span>)</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">False</span>)</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="jupyter_notebook_files/figure-html/cell-36-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-74" class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Modelo 2 vende Modelo 1: </span><span class="sc">{</span>(acc_xgb_2<span class="op">&gt;</span>acc_xgb_1)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span><span class="dv">100</span><span class="op">*</span>(acc_xgb_2<span class="op">&gt;</span>acc_xgb_1)<span class="sc">.</span>mean()<span class="sc">:.0f}</span><span class="ss">%)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Modelo 2 vende Modelo 1: 3 (15%)</code></pre>
</div>
</div>
<p>Nesse caso, o Modelo 2, mesmo com mais covariáveis, não foi o suficiente pra performar que o Modelo 1. Isso porque a covariável ano mais atrapalhava do que ajudava o modelo, afinal, ela, por definição seria extrapolada.</p>
<p>Além disso, é interessante lembrar que o modelo é construído baseado em árvores. Muito provavelmente as primeiras camadas de árvore definiam: “se maior ou igual que 2017”, sendo 2017 o último dado de treino. Nesse caso, o ano 2018 cai nessa regra e o modelo gera uma previsão similar ao do ano 2017. Em resumo, treinamos um modelo moderníssimo para gerar um naive-forecast.</p>
<p><i>Lembrando: poderia ser modelada a covariável “t”, como tempo desde o primeiro dado de treinamento, ao invés de ano. Nesse caso, o problema de extrapolação ainda existiria. <b> Não coloque covariávels que serão extrapoladas no seu modelo de ML!!!</b> </i></p>
</section>
<section id="comentários-finais-ii" class="level1">
<h1>Comentários Finais II:</h1>
<p>Recapitulando o que foi visto:</p>
<ul>
<li>Definiu-se o que são regressões não-paramétricas <br></li>
<li>Foi apresentada uma classe de regressões não-paramétricas, o Gradient Boost Tree Decision <br></li>
<li>Foi explorado os problemas dessa aborgadem na previsão de demanda usando o XGBoost <br></li>
<li>Foi apresentada possíveis soluções para o problema de tendência</li>
</ul>
<p>Lembrando, foi usado o XGBoost, mas poderia ser usado o LightGBM, o KNN, Splines etc. O ponto central está no entendimento da aplicação desses modelos e suas eventuais limitações.</p>
<p>Outro ponto a se destacar foi a importância da remoção da tendência. Apesar de ser um modelo “moderninho” de machine learning, o que ajudou ele a performar melhor foi um approach mais clássico de séries temporais.</p>
<p>Outras alternativas de remoção tendência é o uso do conceito de <i>baseline</i>. No caso, um nível basal onde você acredita que a demanda estará e a responsabildiade do modelo será prever o quanto a série oscila em torno disso. Nesse caso, vc precisaria de uma estimativa para esse baseline vinda de outro modelo.</p>
<p>No mais, trata-se de um modelo promissor. É muito usado quando se trata de uma granulalidade alta, seja no tempo (hora, dia etc), seja na previsão (sku, pdv etc), dado que ele entende fácil padrões estruturais.</p>
</section>
<section id="principais-fontes" class="level1">
<h1>Principais Fontes</h1>
<ul>
<li>Para regressões não-paramétricas, há as notas de aula do professor Lucambio Perez da UFPR: <a href="http://leg.ufpr.br/~lucambio/Nonparam/NparamIV.html" target="_blank" rel="noopener noreferrer">Regressão Não-Paramétrica</a>. <br></li>
<li>Para uma boa introdução ao universo de séries temporais e previsão, o livro <a href="https://otexts.com/fpp3/" target="_blank" rel="noopener noreferrer">Forecasting: Principles &amp; Practice</a>. O livro é todo construído em R, o que pode ser um problema para os pythonistas. Os autores têm excelentes publicações na área de séries temporais, que são devidamente citadas ao longo do livro, então é uma baita livro de cabeceira. <br></li>
<li>Para sofrer um pouquinho com séries temporais e entender a fundo a “lógica” da modelagem de um processo estocástico, o livro <a href="https://www.amazon.com.br/Econometria-S%C3%A9ries-Temporais-Rodrigo-Silveira/dp/852211157X" target="_blank" rel="noopener noreferrer">Econometria de Séries Temporais</a>. Não recomendo como primeira leitura, mas certamente um baita livro para elevar o nível de entendimento no assunto. <br></li>
<li>Para uma introdução no universo do Machine Learning, o livro <a href="https://www.amazon.com.br/M%C3%A3os-obra-aprendizado-scikit-learn-tensorflow/dp/8550803812/ref=sr_1_4?__mk_pt_BR=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;crid=4OWMSIKND5IS&amp;keywords=aprendizado+de+maquina&amp;qid=1703042541&amp;s=books&amp;sprefix=aprendizado+de+maquina%2Cstripbooks%2C262&amp;sr=1-4" target="_blank" rel="noopener noreferrer">Mãos à Obra: Aprendizado de Máquina com Scikit-Learn &amp; TensorFlow</a>. É um livro básico, mas que é legal ter como consulta, como foi o caso na construção do texto. <br></li>
<li>Para mais usos de Aprendizado de Máquina Supervisionado em séries temporais, o livro <a href="https://www.amazon.com.br/Advanced-Forecasting-Python-State-Art-Models/dp/1484271491/ref=sr_1_1?__mk_pt_BR=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;crid=31X3J7B6L1YS&amp;keywords=Advanced+Forecasting+with+Python&amp;qid=1703042592&amp;s=books&amp;sprefix=advanced+forecasting+with+python%2Cstripbooks%2C515&amp;sr=1-1&amp;ufe=app_do%3Aamzn1.fos.4bb5663b-6f7d-4772-84fa-7c7f565ec65b" target="_blank" rel="noopener noreferrer">Advanced Forecasting with Python</a>. Não é tão <i>advanced</i> assim e o autor acaba pecando fortemente na exploração de alguns modelos, mas é o preço que se paga por querer ensinar +10 modelos distintos em menos de 300 pgs. <br></li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>